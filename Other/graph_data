#!/usr/bin/env python

import matplotlib as mpl
mpl.use('Agg')

import os
import sys
import errno
from moseq.util import load_field_from_hdf
import argparse
from matplotlib import pyplot as plt
import matplotlib.cm as cm
from matplotlib.collections import LineCollection
import numpy as np

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("dataset", help="HDF5 file to extract data from")
	parser.add_argument("--dest", default=None, help="Destination directory for generated plots")
	parser.add_argument("--dpi", default=600, type=int, help="DPI of the output figure")

	args = parser.parse_args()
	if args.dest is None:
		args.dest = os.getcwd()
	ensure_dir(args.dest)
	
	mouse_name_dict = load_field_from_hdf(args.dataset, 'mouse_name')
	
	fields = [{ 'row': 0, 'col': 0, 'field': 'angle' }, 
			  { 'row': 1, 'col': 0, 'field': 'width_mm' },
			  { 'row': 2, 'col': 0, 'field': 'height_mm' },
			  { 'row': 3, 'col': 0, 'field': 'length_mm' },
			  { 'row': 4, 'col': 0, 'field': 'velocity' },
			  
			  { 'row': 5, 'col': 0, 'field': 'area_mm2' },
			  { 'row': 6, 'col': 0, 'field': 'dilation' },
			  { 'row': 7, 'col': 0, 'field': 'good_frames' },			  
			  { 'row': 8, 'col': 0, 'field': 'max_height' },
			  { 'row': 9, 'col': 0, 'field': 'plane_offset' },
			  #{ 'row': 10, 'col': 0, 'field': 'min_size' },
              #{ 'row': 7, 'col': 0, 'field': 'fill_window' },
			  
			  { 'row': 0, 'col': 1, 'field': ('head_x_mm', 'head_y_mm') },
			  { 'row': 2, 'col': 1, 'field': ('tail_x_mm', 'tail_y_mm') },
			  { 'row': 4, 'col': 1, 'field': ('centroid_x_mm', 'centroid_y_mm') },
			  { 'row': 6, 'col': 1, 'field': ('centroid_x_px', 'centroid_y_px') },
			  { 'row': 8, 'col': 1, 'field': ('centroid_x_mm_px', 'centroid_y_mm_px') },
			  
			  #disabled this as it is not very informative and rendering in PDF (in ADOBE ACROBAT) is slow
			  #{ 'row': 10, 'col': 1, 'field': ('bg_x_bounds', 'bg_y_bounds') }, 
	]
	
	num_mice = len(mouse_name_dict.keys())
	cur_mouse = 1
	for mn in mouse_name_dict.keys():
		sys.stderr.write("Working on  mouse {}/{}: \"{}\".....\n".format(cur_mouse, num_mice, mn))
		fig = plt.figure(figsize=(10, 20), dpi=600)
		rows = max([f['row']+1 for f in fields])
		cols = max([f['col']+1 for f in fields])
		
		for i in range(len(fields)):
			
			if isinstance(fields[i]['field'], tuple):
				ax = plt.subplot2grid((rows,cols), (fields[i]['row'], fields[i]['col']), rowspan=2)
				plot_field(ax, args.dataset, mn, fields[i]['field'][1], fields[i]['field'][0])
			else:
				ax = plt.subplot2grid((rows,cols), (fields[i]['row'], fields[i]['col']))
				plot_field(ax, args.dataset, mn, fields[i]['field'])
				
		
		fig.suptitle(mn)
		plt.tight_layout(rect=[0, 0.03, 1, 0.95])
		savename = os.path.join(args.dest, "{}.pdf".format(mn))
		fig.savefig(savename, dpi=args.dpi)
		plt.close(fig)
		sys.stderr.write("See plot output at {}\n\n".format(savename))
		cur_mouse += 1
	sys.stderr.write("Done!\n\n")
	
#end main()


def plot_field(ax, dataset, mouse_name, y_field, x_field=None):
    y_data_dict = load_field_from_hdf(dataset, y_field)
    y = y_data_dict[mouse_name]
    time_data = np.arange(0, y.shape[0])

    if x_field == None:
    	has_x_field = False
        x = time_data
        x_field = "Time (Frame Number)"
    else:
    	has_x_field = True
        x_data_dict = load_field_from_hdf(dataset, x_field)
        x = x_data_dict[mouse_name]
    
    if len(y.shape) == 1:
    	if has_x_field:
    		plot_color_line(ax, x, y, time_data)
    	else:
        	ax.plot(x, y, label=y_field)
    else:
        for j in range(y.shape[1]):
        	if has_x_field:
	    		plot_color_line(ax, x.flatten(), y.flatten(), time_data)
	    	else:
	        	ax.plot(x, y[:,j], label=y_field)
    
    ax.set_xlabel(x_field)
    ax.set_ylabel(y_field)
#end plot_field()

def plot_color_line(ax, x, y, c):
    cmap = plt.get_cmap("plasma")
    norm = plt.Normalize()
	
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
#     print x
#     print "MinX: {}; MaxX: {}".format(np.nanmin(x), np.nanmax(x))
#     print y
#     print "MinY: {}; MaxY: {}".format(np.nanmin(y), np.nanmax(y))
#     print c
#     print "MinC: {}; MaxC: {}".format(np.nanmin(c), np.nanmax(c))

    lc = LineCollection(segments, cmap=cmap, norm=norm)
    lc.set_array(c)
    lc.set_linewidth(1)
    ax.add_collection(lc)
    
    min_value = min([np.nanmin(x), np.nanmin(y)])
    max_value = max([np.nanmax(x), np.nanmax(y)])
    
    ax.set_xlim(min_value, max_value)
    ax.set_ylim(min_value, max_value)
    
    axcb = plt.colorbar(lc)
    axcb.set_label('Frame #')

    return
#end plot_color_line()

def ensure_dir(path):
	"""Creats the directories specified by path if they do not already exist.
	"""
	if not os.path.exists(path):
		try:
			os.makedirs(path)
		except OSError as exception:
			#if the exception is raised because the directory already exits,
			#than our work is done and everything is OK, otherwise re-raise the error
			#THIS CAN OCCUR FROM A POSSIBLE RACE CONDITION!!!
			if exception.errno != errno.EEXIST:
				raise
	return path
#end ensure_dir()

if __name__ == "__main__":
	main()
